--- kernel/apic/io_apic.c	2018-03-21 14:40:12.000000000 -0700
+++ arch/x86/kernel/apic/io_apic.c	2018-12-02 07:22:16.524199246 -0800
@@ -1330,8 +1330,12 @@
 			   cpumask_intersects(cfg->old_domain, cpu_online_mask);
 		}
 		for_each_cpu_and(new_cpu, tmp_mask, cpu_online_mask)
+                {       
+	                printk("Alloc cpu = %d,  vector %d, for irq %d\n", new_cpu, vector, irq);
 			per_cpu(vector_irq, new_cpu)[vector] = irq;
-		cfg->vector = vector;
+		}
+                cfg->vector = vector;
+
 		cpumask_copy(cfg->domain, tmp_mask);
 		err = 0;
 		break;
@@ -2299,6 +2303,63 @@
 	cfg->move_in_progress = 0;
 }
 
+////NANNAN: header file
+//
+//#include <linux/swap.h>
+//#include <linux/writeback.h>
+////#include <linux/slab.h>
+//
+//#define RESERVED_MEMORY_OFFSET  0x100000000     /* Offset is 4GB */
+//
+////struct page swap_page;// = (struct page*) kmalloc(sizeof(struct page), GFP_KERNEL);
+//struct writeback_control wbc = {
+//        .sync_mode = WB_SYNC_NONE,
+//};
+//unsigned int dlen = PAGE_SIZE;
+
+///*
+//struct acc_work_struct{
+//    struct page * swap_page;
+//    struct work_struct save_page;
+//};
+//*/
+//struct acc_work_struct test_work;
+//EXPORT_SYMBOL_GPL(test_work);
+//struct workqueue_struct *test_workqueue = NULL;
+//EXPORT_SYMBOL_GPL(test_workqueue);
+//
+//void do_save_page(struct work_struct *p_work)
+//{
+//    int ret = 0;
+//    struct acc_work_struct * save_page_work = container_of(p_work, struct acc_work_struct, save_page);
+//
+//    printk("ret = %d\n", ret);
+//    printk("page addr is %lx\n", (long unsigned int)save_page_work->swap_page);
+//    ret = __swap_writepage(save_page_work->swap_page, &wbc, end_swap_bio_write);
+//
+//    kfree(save_page_work);
+//
+//    return ;
+//}
+//EXPORT_SYMBOL_GPL(do_save_page);
+
+//extern u8 *reserved_memory;
+
+//NANNAN: define the acc interrupt handler
+
+extern atomic_t modified_hw;
+
+asmlinkage void smp_acc_service_interrupt(void)
+{
+	irq_enter();
+	exit_idle();
+
+	atomic_set(&modified_hw, 0);
+    printk("START ACC SERVICE. THIS IS TESTING THE MODIFIED AND TRADTIONAL HARDWARE!\n");
+
+	irq_exit();
+}
+
 asmlinkage void smp_irq_move_cleanup_interrupt(void)
 {
 	unsigned vector, me;
